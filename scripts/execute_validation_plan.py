#!/usr/bin/env python3
"""
Execute the base image validation action plan.

This script reads the action plan generated by validate_base_images.py --dry-run
and executes the necessary actions (create/recreate base images, delete training data).

Usage:
    # Execute the action plan
    python scripts/execute_validation_plan.py
    
    # Execute specific actions only
    python scripts/execute_validation_plan.py --actions create_base_image,recreate_mismatch
    
    # Preview what will be done
    python scripts/execute_validation_plan.py --preview
"""

import sys
import json
import logging
from pathlib import Path
from typing import Dict, List

# Add parent directory to path for imports
project_root = Path(__file__).parent.parent
sys.path.insert(0, str(project_root))

# Load .env file if it exists
try:
    from dotenv import load_dotenv
    env_path = project_root / '.env'
    if env_path.exists():
        load_dotenv(env_path)
        logger_msg = f"Loaded .env from {env_path}"
    else:
        logger_msg = f".env file not found at {env_path}"
except ImportError:
    # If dotenv not installed, try to manually load .env
    import os
    env_path = project_root / '.env'
    if env_path.exists():
        with open(env_path, 'r') as f:
            for line in f:
                line = line.strip()
                if line and not line.startswith('#') and '=' in line:
                    key, value = line.split('=', 1)
                    # Remove quotes if present
                    value = value.strip().strip('"').strip("'")
                    os.environ[key.strip()] = value
        logger_msg = f"Manually loaded .env from {env_path} (python-dotenv not installed)"
    else:
        logger_msg = "python-dotenv not installed and .env file not found"

from src.utils.openai_client import OpenAIClient
from src.utils.image_processing import base64_to_image
from scripts.generate_base_image import generate_base_image
from scripts.delete_all_actor_training_data import delete_all_training_data

logging.basicConfig(
    level=logging.INFO,
    format='[%(levelname)s] %(message)s'
)
logger = logging.getLogger(__name__)


def load_action_plan(plan_path: Path) -> Dict:
    """Load the action plan from JSON file"""
    if not plan_path.exists():
        logger.error(f"Action plan not found at {plan_path}")
        logger.error("Run 'python scripts/validate_base_images.py --dry-run' first to generate the plan")
        sys.exit(1)
    
    try:
        with open(plan_path, 'r') as f:
            plan = json.load(f)
        logger.info(f"Loaded action plan: {plan['actions_needed']} actions to execute")
        return plan
    except Exception as e:
        logger.error(f"Failed to load action plan: {e}")
        sys.exit(1)


def load_actors_data(project_root: Path) -> Dict[int, Dict]:
    """Load actors data and return as dict keyed by actor ID"""
    actors_data_path = project_root / 'data' / 'actorsData.json'
    
    try:
        with open(actors_data_path, 'r') as f:
            actors_list = json.load(f)
        
        # Convert to dict for easy lookup
        actors_dict = {actor['id']: actor for actor in actors_list}
        return actors_dict
    except Exception as e:
        logger.error(f"Failed to load actorsData.json: {e}")
        sys.exit(1)


def execute_action(action: Dict, actors_data: Dict[int, Dict], project_root: Path) -> bool:
    """
    Execute a single action from the plan.
    
    Returns:
        True if successful, False otherwise
    """
    actor_id = action['actor_id']
    actor_name = action['actor_name']
    action_type = action['action']
    
    # Get actor data
    actor = actors_data.get(actor_id)
    if not actor:
        logger.error(f"Actor {actor_id} not found in actorsData.json")
        return False
    
    description = actor.get('description', '')
    outfit = actor.get('outfit', '')
    
    logger.info(f"Executing: {action_type} for actor {actor_id} ({actor_name})")
    
    try:
        # Step 1: Delete training data (for all action types except skip)
        if action_type in ['create_base_image', 'recreate_blurry', 'recreate_mismatch']:
            logger.info("  → Deleting training data...")
            delete_result = delete_all_training_data(actor_name)
            if delete_result != 0:
                logger.warning("  ⚠️  Training data deletion had issues")
        
        # Step 2: Create/recreate base image
        if action_type in ['create_base_image', 'recreate_blurry', 'recreate_mismatch']:
            logger.info("  → Generating base image...")
            gen_result = generate_base_image(
                description=description,
                actor_name=actor_name,
                outfit=outfit,
                width=1024,
                height=1536,
                steps=25,
                seed=-1
            )
            
            if gen_result.get('status') == 'COMPLETED':
                # Extract and save the image
                try:
                    images = gen_result.get('output', {}).get('output', {}).get('images', [])
                    if not images:
                        logger.error("  ❌ No images in result")
                        return False
                    
                    # Convert base64 to PIL Image
                    base64_image = images[0]
                    pil_image = base64_to_image(base64_image)
                    
                    # Save to base_image directory
                    actor_dir = project_root / 'data' / 'actors' / actor_name
                    base_image_dir = actor_dir / 'base_image'
                    base_image_dir.mkdir(parents=True, exist_ok=True)
                    
                    # Save as JPG (matching existing base images)
                    output_path = base_image_dir / f"{actor_name}_base.jpg"
                    pil_image.save(output_path, 'JPEG', quality=95)
                    
                    logger.info(f"  → Saved to: {output_path}")
                    logger.info("  ✅ Success")
                    return True
                    
                except Exception as e:
                    logger.error(f"  ❌ Failed to save image: {e}")
                    return False
            else:
                logger.error(f"  ❌ Failed: {gen_result.get('error')}")
                return False
        
        return True
        
    except Exception as e:
        logger.error(f"  ❌ Error: {e}")
        return False


def load_execution_checkpoint(checkpoint_path: Path) -> set:
    """Load executed actor IDs from checkpoint file"""
    if checkpoint_path.exists():
        try:
            with open(checkpoint_path, 'r') as f:
                data = json.load(f)
                executed_ids = set(data.get('executed_actor_ids', []))
                logger.info(f"Loaded checkpoint: {len(executed_ids)} actors already executed")
                return executed_ids
        except Exception as e:
            logger.warning(f"Failed to load checkpoint: {e}")
    return set()


def save_execution_checkpoint(checkpoint_path: Path, executed_ids: set) -> None:
    """Save executed actor IDs to checkpoint file"""
    try:
        with open(checkpoint_path, 'w') as f:
            json.dump({
                'executed_actor_ids': list(executed_ids),
                'last_updated': str(Path(__file__).parent.parent)
            }, f, indent=2)
    except Exception as e:
        logger.warning(f"Failed to save checkpoint: {e}")


def main():
    """Main entry point"""
    import argparse
    
    parser = argparse.ArgumentParser(description='Execute base image validation action plan')
    parser.add_argument(
        '--preview',
        action='store_true',
        help='Preview actions without executing them'
    )
    parser.add_argument(
        '--actions',
        type=str,
        help='Comma-separated list of action types to execute (e.g., "create_base_image,recreate_mismatch")'
    )
    parser.add_argument(
        '--resume',
        action='store_true',
        help='Resume from checkpoint (skip already executed actors)'
    )
    parser.add_argument(
        '--reset-checkpoint',
        action='store_true',
        help='Delete checkpoint and start fresh'
    )
    
    args = parser.parse_args()
    
    # Checkpoint file path
    checkpoint_path = project_root / 'debug' / 'base_image_execution_checkpoint.json'
    checkpoint_path.parent.mkdir(exist_ok=True)
    
    # Handle checkpoint reset
    if args.reset_checkpoint:
        if checkpoint_path.exists():
            checkpoint_path.unlink()
            logger.info("Checkpoint deleted - starting fresh")
        else:
            logger.info("No checkpoint to delete")
    
    # Load checkpoint if resuming
    executed_ids = set()
    if args.resume:
        executed_ids = load_execution_checkpoint(checkpoint_path)
    
    # Load action plan
    plan_path = project_root / 'debug' / 'base_image_validation_action_plan.json'
    plan = load_action_plan(plan_path)
    
    # Load actors data
    actors_data = load_actors_data(project_root)
    
    # Filter actions if specific types requested
    actions = plan['actions']
    if args.actions:
        action_types = [a.strip() for a in args.actions.split(',')]
        actions = [a for a in actions if a['action'] in action_types]
        logger.info(f"Filtered to {len(actions)} actions of types: {', '.join(action_types)}")
    
    # Filter out already executed actors if resuming
    if args.resume and executed_ids:
        original_count = len(actions)
        actions = [a for a in actions if a['actor_id'] not in executed_ids]
        logger.info(f"RESUME MODE: Skipping {original_count - len(actions)} already executed actors")
        logger.info(f"Executing remaining {len(actions)} actions")
    
    if not actions:
        logger.info("No actions to execute")
        sys.exit(0)
    
    # Preview mode
    if args.preview:
        logger.info("="*80)
        logger.info("PREVIEW MODE - No changes will be made")
        logger.info("="*80)
        
        for i, action in enumerate(actions, 1):
            logger.info(f"\n[{i}/{len(actions)}] {action['action']}")
            logger.info(f"  Actor: {action['actor_name']} (ID: {action['actor_id']})")
            logger.info(f"  Reason: {action['reason']}")
        
        logger.info("\n" + "="*80)
        logger.info(f"Total actions: {len(actions)}")
        logger.info("Run without --preview to execute")
        logger.info("="*80)
        sys.exit(0)
    
    # Execute actions
    logger.info("="*80)
    logger.info("EXECUTING ACTION PLAN")
    logger.info("="*80)
    logger.info(f"Total actions to execute: {len(actions)}")
    logger.info("")
    
    results = []
    for i, action in enumerate(actions, 1):
        actor_id = action['actor_id']
        
        try:
            logger.info(f"[{i}/{len(actions)}] Processing actor {actor_id}...")
            success = execute_action(action, actors_data, project_root)
            results.append({
                'actor_id': actor_id,
                'actor_name': action['actor_name'],
                'action': action['action'],
                'success': success
            })
            
            # Save checkpoint after each actor
            executed_ids.add(actor_id)
            save_execution_checkpoint(checkpoint_path, executed_ids)
            logger.info("")
            
        except KeyboardInterrupt:
            logger.warning("\n⚠️  Interrupted by user")
            logger.info(f"Progress saved: {len(executed_ids)} actors executed")
            logger.info(f"Resume with: python scripts/execute_validation_plan.py --resume")
            sys.exit(130)
            
        except Exception as e:
            logger.error(f"Unexpected error: {e}")
            results.append({
                'actor_id': actor_id,
                'actor_name': action['actor_name'],
                'action': action['action'],
                'success': False
            })
            # Still mark as executed to avoid retrying
            executed_ids.add(actor_id)
            save_execution_checkpoint(checkpoint_path, executed_ids)
            logger.info("")
    
    # Summary
    logger.info("="*80)
    logger.info("EXECUTION SUMMARY")
    logger.info("="*80)
    
    successful = sum(1 for r in results if r['success'])
    failed = sum(1 for r in results if not r['success'])
    
    logger.info(f"Total actions: {len(results)}")
    logger.info(f"Successful: {successful}")
    logger.info(f"Failed: {failed}")
    
    # Save execution results
    results_path = project_root / 'debug' / 'base_image_validation_execution_results.json'
    with open(results_path, 'w') as f:
        json.dump({
            'total_actions': len(results),
            'successful': successful,
            'failed': failed,
            'results': results
        }, f, indent=2)
    
    logger.info(f"\nExecution results saved to: {results_path}")
    logger.info("="*80)
    
    # Exit with appropriate code
    sys.exit(0 if failed == 0 else 1)


if __name__ == "__main__":
    main()
